// Code generated by counterfeiter. DO NOT EDIT.
package servicesfake

import (
	"os"
	"sync"

	"github.com/xcomponent/xc-cli/services"
)

type FakeOsService struct {
	CreateStub        func(name string) (*os.File, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		name string
	}
	createReturns struct {
		result1 *os.File
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 *os.File
		result2 error
	}
	ExitStub        func(exitCode int)
	exitMutex       sync.RWMutex
	exitArgsForCall []struct {
		exitCode int
	}
	GetwdStub        func() (string, error)
	getwdMutex       sync.RWMutex
	getwdArgsForCall []struct{}
	getwdReturns     struct {
		result1 string
		result2 error
	}
	getwdReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetPathSeperatorStub        func() rune
	getPathSeperatorMutex       sync.RWMutex
	getPathSeperatorArgsForCall []struct{}
	getPathSeperatorReturns     struct {
		result1 rune
	}
	getPathSeperatorReturnsOnCall map[int]struct {
		result1 rune
	}
	IsNotExistStub        func(err error) bool
	isNotExistMutex       sync.RWMutex
	isNotExistArgsForCall []struct {
		err error
	}
	isNotExistReturns struct {
		result1 bool
	}
	isNotExistReturnsOnCall map[int]struct {
		result1 bool
	}
	MkdirStub        func(name string, perm os.FileMode) error
	mkdirMutex       sync.RWMutex
	mkdirArgsForCall []struct {
		name string
		perm os.FileMode
	}
	mkdirReturns struct {
		result1 error
	}
	mkdirReturnsOnCall map[int]struct {
		result1 error
	}
	MkdirAllStub        func(path string, perm os.FileMode) error
	mkdirAllMutex       sync.RWMutex
	mkdirAllArgsForCall []struct {
		path string
		perm os.FileMode
	}
	mkdirAllReturns struct {
		result1 error
	}
	mkdirAllReturnsOnCall map[int]struct {
		result1 error
	}
	OpenStub        func(name string) (*os.File, error)
	openMutex       sync.RWMutex
	openArgsForCall []struct {
		name string
	}
	openReturns struct {
		result1 *os.File
		result2 error
	}
	openReturnsOnCall map[int]struct {
		result1 *os.File
		result2 error
	}
	OpenFileStub        func(name string, flag int, perm os.FileMode) (*os.File, error)
	openFileMutex       sync.RWMutex
	openFileArgsForCall []struct {
		name string
		flag int
		perm os.FileMode
	}
	openFileReturns struct {
		result1 *os.File
		result2 error
	}
	openFileReturnsOnCall map[int]struct {
		result1 *os.File
		result2 error
	}
	RemoveStub        func(name string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		name string
	}
	removeReturns struct {
		result1 error
	}
	removeReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveAllStub        func(path string) error
	removeAllMutex       sync.RWMutex
	removeAllArgsForCall []struct {
		path string
	}
	removeAllReturns struct {
		result1 error
	}
	removeAllReturnsOnCall map[int]struct {
		result1 error
	}
	RenameStub        func(oldpath string, newpath string) error
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		oldpath string
		newpath string
	}
	renameReturns struct {
		result1 error
	}
	renameReturnsOnCall map[int]struct {
		result1 error
	}
	StatStub        func(name string) (os.FileInfo, error)
	statMutex       sync.RWMutex
	statArgsForCall []struct {
		name string
	}
	statReturns struct {
		result1 os.FileInfo
		result2 error
	}
	statReturnsOnCall map[int]struct {
		result1 os.FileInfo
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeOsService) Create(name string) (*os.File, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Create", []interface{}{name})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createReturns.result1, fake.createReturns.result2
}

func (fake *FakeOsService) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeOsService) CreateArgsForCall(i int) string {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].name
}

func (fake *FakeOsService) CreateReturns(result1 *os.File, result2 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOsService) CreateReturnsOnCall(i int, result1 *os.File, result2 error) {
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 *os.File
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOsService) Exit(exitCode int) {
	fake.exitMutex.Lock()
	fake.exitArgsForCall = append(fake.exitArgsForCall, struct {
		exitCode int
	}{exitCode})
	fake.recordInvocation("Exit", []interface{}{exitCode})
	fake.exitMutex.Unlock()
	if fake.ExitStub != nil {
		fake.ExitStub(exitCode)
	}
}

func (fake *FakeOsService) ExitCallCount() int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return len(fake.exitArgsForCall)
}

func (fake *FakeOsService) ExitArgsForCall(i int) int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return fake.exitArgsForCall[i].exitCode
}

func (fake *FakeOsService) Getwd() (string, error) {
	fake.getwdMutex.Lock()
	ret, specificReturn := fake.getwdReturnsOnCall[len(fake.getwdArgsForCall)]
	fake.getwdArgsForCall = append(fake.getwdArgsForCall, struct{}{})
	fake.recordInvocation("Getwd", []interface{}{})
	fake.getwdMutex.Unlock()
	if fake.GetwdStub != nil {
		return fake.GetwdStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getwdReturns.result1, fake.getwdReturns.result2
}

func (fake *FakeOsService) GetwdCallCount() int {
	fake.getwdMutex.RLock()
	defer fake.getwdMutex.RUnlock()
	return len(fake.getwdArgsForCall)
}

func (fake *FakeOsService) GetwdReturns(result1 string, result2 error) {
	fake.GetwdStub = nil
	fake.getwdReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOsService) GetwdReturnsOnCall(i int, result1 string, result2 error) {
	fake.GetwdStub = nil
	if fake.getwdReturnsOnCall == nil {
		fake.getwdReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getwdReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOsService) GetPathSeperator() rune {
	fake.getPathSeperatorMutex.Lock()
	ret, specificReturn := fake.getPathSeperatorReturnsOnCall[len(fake.getPathSeperatorArgsForCall)]
	fake.getPathSeperatorArgsForCall = append(fake.getPathSeperatorArgsForCall, struct{}{})
	fake.recordInvocation("GetPathSeperator", []interface{}{})
	fake.getPathSeperatorMutex.Unlock()
	if fake.GetPathSeperatorStub != nil {
		return fake.GetPathSeperatorStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getPathSeperatorReturns.result1
}

func (fake *FakeOsService) GetPathSeperatorCallCount() int {
	fake.getPathSeperatorMutex.RLock()
	defer fake.getPathSeperatorMutex.RUnlock()
	return len(fake.getPathSeperatorArgsForCall)
}

func (fake *FakeOsService) GetPathSeperatorReturns(result1 rune) {
	fake.GetPathSeperatorStub = nil
	fake.getPathSeperatorReturns = struct {
		result1 rune
	}{result1}
}

func (fake *FakeOsService) GetPathSeperatorReturnsOnCall(i int, result1 rune) {
	fake.GetPathSeperatorStub = nil
	if fake.getPathSeperatorReturnsOnCall == nil {
		fake.getPathSeperatorReturnsOnCall = make(map[int]struct {
			result1 rune
		})
	}
	fake.getPathSeperatorReturnsOnCall[i] = struct {
		result1 rune
	}{result1}
}

func (fake *FakeOsService) IsNotExist(err error) bool {
	fake.isNotExistMutex.Lock()
	ret, specificReturn := fake.isNotExistReturnsOnCall[len(fake.isNotExistArgsForCall)]
	fake.isNotExistArgsForCall = append(fake.isNotExistArgsForCall, struct {
		err error
	}{err})
	fake.recordInvocation("IsNotExist", []interface{}{err})
	fake.isNotExistMutex.Unlock()
	if fake.IsNotExistStub != nil {
		return fake.IsNotExistStub(err)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isNotExistReturns.result1
}

func (fake *FakeOsService) IsNotExistCallCount() int {
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	return len(fake.isNotExistArgsForCall)
}

func (fake *FakeOsService) IsNotExistArgsForCall(i int) error {
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	return fake.isNotExistArgsForCall[i].err
}

func (fake *FakeOsService) IsNotExistReturns(result1 bool) {
	fake.IsNotExistStub = nil
	fake.isNotExistReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOsService) IsNotExistReturnsOnCall(i int, result1 bool) {
	fake.IsNotExistStub = nil
	if fake.isNotExistReturnsOnCall == nil {
		fake.isNotExistReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isNotExistReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOsService) Mkdir(name string, perm os.FileMode) error {
	fake.mkdirMutex.Lock()
	ret, specificReturn := fake.mkdirReturnsOnCall[len(fake.mkdirArgsForCall)]
	fake.mkdirArgsForCall = append(fake.mkdirArgsForCall, struct {
		name string
		perm os.FileMode
	}{name, perm})
	fake.recordInvocation("Mkdir", []interface{}{name, perm})
	fake.mkdirMutex.Unlock()
	if fake.MkdirStub != nil {
		return fake.MkdirStub(name, perm)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mkdirReturns.result1
}

func (fake *FakeOsService) MkdirCallCount() int {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	return len(fake.mkdirArgsForCall)
}

func (fake *FakeOsService) MkdirArgsForCall(i int) (string, os.FileMode) {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	return fake.mkdirArgsForCall[i].name, fake.mkdirArgsForCall[i].perm
}

func (fake *FakeOsService) MkdirReturns(result1 error) {
	fake.MkdirStub = nil
	fake.mkdirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOsService) MkdirReturnsOnCall(i int, result1 error) {
	fake.MkdirStub = nil
	if fake.mkdirReturnsOnCall == nil {
		fake.mkdirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOsService) MkdirAll(path string, perm os.FileMode) error {
	fake.mkdirAllMutex.Lock()
	ret, specificReturn := fake.mkdirAllReturnsOnCall[len(fake.mkdirAllArgsForCall)]
	fake.mkdirAllArgsForCall = append(fake.mkdirAllArgsForCall, struct {
		path string
		perm os.FileMode
	}{path, perm})
	fake.recordInvocation("MkdirAll", []interface{}{path, perm})
	fake.mkdirAllMutex.Unlock()
	if fake.MkdirAllStub != nil {
		return fake.MkdirAllStub(path, perm)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mkdirAllReturns.result1
}

func (fake *FakeOsService) MkdirAllCallCount() int {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return len(fake.mkdirAllArgsForCall)
}

func (fake *FakeOsService) MkdirAllArgsForCall(i int) (string, os.FileMode) {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return fake.mkdirAllArgsForCall[i].path, fake.mkdirAllArgsForCall[i].perm
}

func (fake *FakeOsService) MkdirAllReturns(result1 error) {
	fake.MkdirAllStub = nil
	fake.mkdirAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOsService) MkdirAllReturnsOnCall(i int, result1 error) {
	fake.MkdirAllStub = nil
	if fake.mkdirAllReturnsOnCall == nil {
		fake.mkdirAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdirAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOsService) Open(name string) (*os.File, error) {
	fake.openMutex.Lock()
	ret, specificReturn := fake.openReturnsOnCall[len(fake.openArgsForCall)]
	fake.openArgsForCall = append(fake.openArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Open", []interface{}{name})
	fake.openMutex.Unlock()
	if fake.OpenStub != nil {
		return fake.OpenStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.openReturns.result1, fake.openReturns.result2
}

func (fake *FakeOsService) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakeOsService) OpenArgsForCall(i int) string {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return fake.openArgsForCall[i].name
}

func (fake *FakeOsService) OpenReturns(result1 *os.File, result2 error) {
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOsService) OpenReturnsOnCall(i int, result1 *os.File, result2 error) {
	fake.OpenStub = nil
	if fake.openReturnsOnCall == nil {
		fake.openReturnsOnCall = make(map[int]struct {
			result1 *os.File
			result2 error
		})
	}
	fake.openReturnsOnCall[i] = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOsService) OpenFile(name string, flag int, perm os.FileMode) (*os.File, error) {
	fake.openFileMutex.Lock()
	ret, specificReturn := fake.openFileReturnsOnCall[len(fake.openFileArgsForCall)]
	fake.openFileArgsForCall = append(fake.openFileArgsForCall, struct {
		name string
		flag int
		perm os.FileMode
	}{name, flag, perm})
	fake.recordInvocation("OpenFile", []interface{}{name, flag, perm})
	fake.openFileMutex.Unlock()
	if fake.OpenFileStub != nil {
		return fake.OpenFileStub(name, flag, perm)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.openFileReturns.result1, fake.openFileReturns.result2
}

func (fake *FakeOsService) OpenFileCallCount() int {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	return len(fake.openFileArgsForCall)
}

func (fake *FakeOsService) OpenFileArgsForCall(i int) (string, int, os.FileMode) {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	return fake.openFileArgsForCall[i].name, fake.openFileArgsForCall[i].flag, fake.openFileArgsForCall[i].perm
}

func (fake *FakeOsService) OpenFileReturns(result1 *os.File, result2 error) {
	fake.OpenFileStub = nil
	fake.openFileReturns = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOsService) OpenFileReturnsOnCall(i int, result1 *os.File, result2 error) {
	fake.OpenFileStub = nil
	if fake.openFileReturnsOnCall == nil {
		fake.openFileReturnsOnCall = make(map[int]struct {
			result1 *os.File
			result2 error
		})
	}
	fake.openFileReturnsOnCall[i] = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOsService) Remove(name string) error {
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Remove", []interface{}{name})
	fake.removeMutex.Unlock()
	if fake.RemoveStub != nil {
		return fake.RemoveStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeReturns.result1
}

func (fake *FakeOsService) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakeOsService) RemoveArgsForCall(i int) string {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return fake.removeArgsForCall[i].name
}

func (fake *FakeOsService) RemoveReturns(result1 error) {
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOsService) RemoveReturnsOnCall(i int, result1 error) {
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOsService) RemoveAll(path string) error {
	fake.removeAllMutex.Lock()
	ret, specificReturn := fake.removeAllReturnsOnCall[len(fake.removeAllArgsForCall)]
	fake.removeAllArgsForCall = append(fake.removeAllArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("RemoveAll", []interface{}{path})
	fake.removeAllMutex.Unlock()
	if fake.RemoveAllStub != nil {
		return fake.RemoveAllStub(path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeAllReturns.result1
}

func (fake *FakeOsService) RemoveAllCallCount() int {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	return len(fake.removeAllArgsForCall)
}

func (fake *FakeOsService) RemoveAllArgsForCall(i int) string {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	return fake.removeAllArgsForCall[i].path
}

func (fake *FakeOsService) RemoveAllReturns(result1 error) {
	fake.RemoveAllStub = nil
	fake.removeAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOsService) RemoveAllReturnsOnCall(i int, result1 error) {
	fake.RemoveAllStub = nil
	if fake.removeAllReturnsOnCall == nil {
		fake.removeAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOsService) Rename(oldpath string, newpath string) error {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		oldpath string
		newpath string
	}{oldpath, newpath})
	fake.recordInvocation("Rename", []interface{}{oldpath, newpath})
	fake.renameMutex.Unlock()
	if fake.RenameStub != nil {
		return fake.RenameStub(oldpath, newpath)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.renameReturns.result1
}

func (fake *FakeOsService) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakeOsService) RenameArgsForCall(i int) (string, string) {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return fake.renameArgsForCall[i].oldpath, fake.renameArgsForCall[i].newpath
}

func (fake *FakeOsService) RenameReturns(result1 error) {
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOsService) RenameReturnsOnCall(i int, result1 error) {
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOsService) Stat(name string) (os.FileInfo, error) {
	fake.statMutex.Lock()
	ret, specificReturn := fake.statReturnsOnCall[len(fake.statArgsForCall)]
	fake.statArgsForCall = append(fake.statArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Stat", []interface{}{name})
	fake.statMutex.Unlock()
	if fake.StatStub != nil {
		return fake.StatStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.statReturns.result1, fake.statReturns.result2
}

func (fake *FakeOsService) StatCallCount() int {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return len(fake.statArgsForCall)
}

func (fake *FakeOsService) StatArgsForCall(i int) string {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return fake.statArgsForCall[i].name
}

func (fake *FakeOsService) StatReturns(result1 os.FileInfo, result2 error) {
	fake.StatStub = nil
	fake.statReturns = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeOsService) StatReturnsOnCall(i int, result1 os.FileInfo, result2 error) {
	fake.StatStub = nil
	if fake.statReturnsOnCall == nil {
		fake.statReturnsOnCall = make(map[int]struct {
			result1 os.FileInfo
			result2 error
		})
	}
	fake.statReturnsOnCall[i] = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeOsService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	fake.getwdMutex.RLock()
	defer fake.getwdMutex.RUnlock()
	fake.getPathSeperatorMutex.RLock()
	defer fake.getPathSeperatorMutex.RUnlock()
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeOsService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ services.OsService = new(FakeOsService)
